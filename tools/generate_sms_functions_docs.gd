extends SceneTree

var REPO_ROOT := "" # CHANGE
var SPEC_DIR := ""  # CHANGE
var OUT_PATH := ""  # CHANGE
var GENERATED_DIR := "" # CHANGE
var GENERATED_CS_PATH := "" # CHANGE

func _initialize() -> void: # CHANGE
    REPO_ROOT = ProjectSettings.globalize_path("res://") + "/.." # CHANGE
    SPEC_DIR = REPO_ROOT + "/tools/specs" # CHANGE
    OUT_PATH = REPO_ROOT + "/docs/sms_functions.md" # CHANGE
    GENERATED_DIR = REPO_ROOT + "/ForgeRunner/Generated" # CHANGE
    GENERATED_CS_PATH = GENERATED_DIR + "/SchemaFunctions.cs" # CHANGE
    generate() # CHANGE
    quit() # CHANGE

func generate() -> void:
    DirAccess.make_dir_recursive_absolute(GENERATED_DIR)

    var md := "# SMS Runtime Functions\n\n"
    md += "This document lists built-in SMS runtime helper functions available in Forge.\n\n"

    var spec_path := SPEC_DIR + "/functions.gd" # CHANGE

    var spec_res := load(spec_path)
    if spec_res == null:
        var spec_uri := "file:///" + spec_path.substr(1)
        spec_res = load(spec_uri)

    if spec_res == null:
        push_error("Failed to load functions spec: " + spec_path)
        return

    var functions: Dictionary = spec_res.FUNCTIONS

    # Group functions by category
    var grouped := {}
    for name in functions.keys():
        var f: Dictionary = functions[name] # CHANGE
        var category := String(f.get("category", "Misc"))
        if not grouped.has(category):
            grouped[category] = []
        grouped[category].append(name)

    var categories := grouped.keys()
    categories.sort()

    for category in categories:
        md += "## %s\n\n" % category
        var names: Array = grouped[category] # CHANGE
        names.sort()

        for name in names:
            var f: Dictionary = functions[name] # CHANGE
            var signature := String(f.get("signature", name))
            var description := String(f.get("description", ""))

            md += "### %s\n" % signature
            md += "%s\n\n" % description

    _generate_schema_functions_cs(functions)

    var file := FileAccess.open(OUT_PATH, FileAccess.WRITE) # CHANGE
    if file:
        file.store_string(md)
        file.close()
        print("SMS functions documentation generated.")
    else:
        push_error("Failed to write SMS functions documentation.")

static func get_spec() -> Dictionary:
    return {
        "name": "sms_functions",
        "elements": []
    }


func _generate_schema_functions_cs(functions: Dictionary) -> void:
    var keys := functions.keys()
    keys.sort()

    var cs := ""
    cs += "// <auto-generated />\n"
    cs += "#nullable enable\n"
    cs += "using System;\n"
    cs += "using System.Collections.Generic;\n\n"
    cs += "namespace Runtime.Generated;\n\n"
    cs += "public sealed record FunctionDef(string Name, string Category, string Signature, string Description);\n\n"
    cs += "public static class SchemaFunctions\n"
    cs += "{\n"
    cs += "    public static readonly FunctionDef[] All =\n"
    cs += "    [\n"

    for k in keys:
        var name := String(k)
        var f: Dictionary = functions[k]
        var category := String(f.get("category", "Misc"))
        var signature := String(f.get("signature", name))
        var description := String(f.get("description", ""))

        cs += "        new FunctionDef(\"%s\", \"%s\", \"%s\", \"%s\"),\n" % [
            _cs_escape(name),
            _cs_escape(category),
            _cs_escape(signature),
            _cs_escape(description)
        ]

    cs += "    ];\n\n"
    cs += "    public static readonly IReadOnlyDictionary<string, FunctionDef> ByName = BuildByName();\n\n"
    cs += "    private static IReadOnlyDictionary<string, FunctionDef> BuildByName()\n"
    cs += "    {\n"
    cs += "        var map = new Dictionary<string, FunctionDef>(StringComparer.OrdinalIgnoreCase);\n"
    cs += "        foreach (var def in All)\n"
    cs += "        {\n"
    cs += "            map[def.Name] = def;\n"
    cs += "        }\n\n"
    cs += "        return map;\n"
    cs += "    }\n"
    cs += "}\n"

    var file := FileAccess.open(GENERATED_CS_PATH, FileAccess.WRITE)
    if file:
        file.store_string(cs)
        file.close()


func _cs_escape(raw: String) -> String:
    return raw.replace("\\", "\\\\").replace("\"", "\\\"")